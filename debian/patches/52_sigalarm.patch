Index: b/syslogd/syslogd.c
===================================================================
--- a/syslogd/syslogd.c	2008-04-11 06:58:34.000000000 +0300
+++ b/syslogd/syslogd.c	2008-04-11 07:16:16.000000000 +0300
@@ -268,6 +268,7 @@ void cfline (const char *, struct filed 
 const char *cvthname (struct sockaddr_in *);
 int decode (const char *, CODE *);
 void die (int);
+void doexit (int);
 void domark (int);
 void fprintlog (struct filed *, const char *, int, const char *);
 static int load_conffile (const char *, struct filed **);
@@ -477,6 +478,7 @@ main (int argc, char *argv[])
 
 	 IMO, the GNU/Linux distributors should fix there booting
 	 sequence. But we still keep the approach.  */
+      signal (SIGTERM, doexit);
       ppid = waitdaemon (0, 0, 30);
       if (ppid < 0)
 	{
@@ -623,7 +625,7 @@ main (int argc, char *argv[])
   /* If we're doing waitdaemon(), tell the parent to exit,
      we are ready to roll.  */
   if (ppid)
-    kill (ppid, SIGALRM);
+    kill (ppid, SIGTERM);
 
   for (;;)
     {
@@ -1553,6 +1555,12 @@ logerror (const char *type)
 }
 
 RETSIGTYPE
+doexit (int signo ARG_UNUSED)
+{
+  exit (0);
+}
+
+RETSIGTYPE
 die (int signo)
 {
   struct filed *f;
